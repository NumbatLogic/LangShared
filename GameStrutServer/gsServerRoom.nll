namespace NumbatLogic
{
	class gsServerRoom_SyncHandler
	{
		public delegate void SyncHandler(gsServerRoom pRoom, Uint32 nSyncId, Uint32 nSyncType, gsBlob pInBlob, gsServerClient pServerClient);

		public Uint32 __nHash;
		public SyncHandler __pHandler;

		public construct(Uint32 nHash, SyncHandler pHandler)
		{
			__nHash = nHash;
			__pHandler = pHandler;
		}
	}

	class gsServerRoom
	{
		public gsServerClient GetClientByClientId(Uint32 nClientId)
		{
			for (int i = 0; i < __pClientVector.GetSize(); i++)
			{
				gsServerClient pClient = __pClientVector.Get(i);
				if (pClient.__nClientId == nClientId)
					return pClient;
			}
			return null;
		}

		private virtual gsBlob** OnClientJoin(gsServerClient pClient)
		{
			return new gsBlob();
		}

		private virtual void OnClientLeave(gsServerClient pClient)
		{

		}

		public void RegisterHandler(Uint32 nSyncType, gsServerRoom_SyncHandler::SyncHandler pHandler)
		{
			if (__GetSyncHandler(nSyncType) != null)
			{
				Console::Log("Server room sync handler hash already registered!");
				Assert::Plz(false);
			}
			__pSyncHandlerVector.PushBack(new gsServerRoom_SyncHandler(nSyncType, pHandler));
		}

		public gsServerRoom_SyncHandler __GetSyncHandler(Uint32 nSyncType)
		{
			for (int i = 0; i < __pSyncHandlerVector.GetSize(); i++)
			{
				gsServerRoom_SyncHandler pInfo = __pSyncHandlerVector.Get(i);
				if (pInfo.__nHash == nSyncType)
					return pInfo;
			}
			return null;
		}

		// SEKRIT
		public Uint32 __nRoomId;
		public Uint32 __nRoomType;
		public InternalString* __sRoomType;
		//public bool __bPrimary;
		public gsServer __pServer;
		public Vector<gsServerClient>* __pClientVector;
		public OwnedVector<gsServerRoom_SyncHandler>* __pSyncHandlerVector;

		public construct(Uint32 nRoomId, string sxRoomType, gsServer pServer)
		{
			__nRoomId = nRoomId;
			__nRoomType = ExternalString::GetChecksum(sxRoomType);
			__sRoomType = own new InternalString(sxRoomType);
			__pServer = pServer;
			__pClientVector = own new Vector<gsServerClient>();
			__pSyncHandlerVector = own new OwnedVector<gsServerRoom_SyncHandler>();
		}
		
		public void __ClientJoin(gsServerClient pClient)
		{
			Assert::Plz(GetClientByClientId(pClient.__nClientId) == null);

			__pClientVector.PushBack(pClient);
			pClient.__pRoomVector.PushBack(this);
			gsBlob* pJoinBlob = own OnClientJoin(pClient);

			gsBlob* pBlob = own new gsBlob();
			pBlob.PackUint32(__nRoomId);
			pBlob.PackUint32(__nRoomType);
			pBlob.PackBool(false /*__bPrimary*/);
			pBlob.PackBlob(pJoinBlob);

			pClient.Send(null, gsClient::__ROOM_JOIN_HASH, pBlob);
		}

		public void __ClientLeave(gsServerClient pClient)
		{
			for (int i = 0; i < __pClientVector.GetSize(); i++)
			{
				if (__pClientVector.Get(i) == pClient)
				{
					OnClientLeave(pClient);
					__pClientVector.Erase(i);

					for (int j = 0; j < pClient.__pRoomVector.GetSize(); j++)
					{
						if (pClient.__pRoomVector.Get(j) == this)
						{
							pClient.__pRoomVector.Erase(j);

							gsBlob* pBlob = own new gsBlob();
								pBlob.PackUint32(__nRoomId);
								pBlob.PackUint32(__nRoomType);
							pClient.Send(null, gsClient::__ROOM_LEAVE_HASH, pBlob);
							return;
						}
					}

					// client in room but room not in client
					Assert::Plz(false);
				}
			}

			// client not in this room!
			Assert::Plz(false);
		}
	}
}