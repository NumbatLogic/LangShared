namespace NumbatLogic
{
	class gsServerClient
	{
		public void Send(gsServerRoom pRoom, string sxMessageType, Blob pBlob)
		{
			Blob* pSendBlob = own new Blob(true);
			BlobView pSendBlobView = pSendBlob.GetBlobView();

			Uint32 nSyncId = __nLastSyncId++;

			pSendBlobView.PackUint32(nSyncId);

			Console::Log("gsServerClient::Send");
			__pClientSocket.Send(pSendBlob);
		}


		// SEKRIT


		/*Uint8 nState;

		Uint16 nNettleVersion;
		Uint16 nVersion;

		Uint32 nClientId;
		//Uint32 nReconnectToken;

		nbVector* pRoomVector;

		Uint32 nLastSyncId;

		void* pPointer;*/
	
		public Uint32 __nClientId;
		public gsServer __pServer;
		public ClientSocket __pClientSocket;
		public gsClient::State __eState;
		public Vector<gsServerRoom>* __pRoomVector;

		public Uint32 __nLastSyncId;

		public construct(Uint32 nClientId, gsServer pServer, ClientSocket pClientSocket)
		{
			__nClientId = nClientId;
			__pServer = pServer;
			__pClientSocket = pClientSocket;
			__eState = gsClient::State::CONNECT;
			__pRoomVector = own new Vector<gsServerRoom>();
		}

		public void __Update()
		{
			__pClientSocket.Update();

			switch (__eState)
			{
				case gsClient::State::CONNECT:
				{
					//if (nbClientSocket_GetConnected(pClient->pClientSocket))
						__eState = gsClient::State::HANDSHAKE;
					break;
				}
				case gsClient::State::HANDSHAKE:
				{
					Blob* pReceiveBlob = own __pClientSocket.Receive();
					if (pReceiveBlob != null)
					{
						const int INITIAL_SIZE = 2 + 2 + 1;
						if (pReceiveBlob.GetSize() > INITIAL_SIZE)
						{
							BlobView pRecieveBlobView = pReceiveBlob.GetBlobView();

							Uint16 nMagic = pRecieveBlobView.UnpackUint16();
							Uint16 nVersion = pRecieveBlobView.UnpackUint16();
							Uint8 nAuthMode = pRecieveBlobView.UnpackUint8();
							
							if (nMagic == gsClient::MAGIC_WORD && nVersion == __pServer.__nVersion)
							{
								// success, move to room or auth or something
								if (nAuthMode == 0)
								{
									InternalString* sName = own new InternalString("");
									InternalString* sPassword = own new InternalString("");

									if (pRecieveBlobView.UnpackInternalString(sName))
									{
										if (pRecieveBlobView.UnpackInternalString(sPassword))
										{

											// TODO: validate


											Console::Log("server send");
											Blob* pSendBlob = own new Blob(true);
											BlobView pBlobView = pSendBlob.GetBlobView();
											pBlobView.PackUint16(gsClient::MAGIC_WORD);
											pBlobView.PackUint16(__pServer.__nVersion);
											pBlobView.PackBool(true);
											pBlobView.PackUint32(__nClientId);

											__pClientSocket.Send(pSendBlob);




											__eState = gsClient::State::CONNECTED;


											// todo: move to some create calback
											gsServerRoom* pOwnedServerRoom = own new gsServerRoom(__pServer.__nLastRoomId++, "test", __pServer);
											gsServerRoom pServerRoom = pOwnedServerRoom;
											__pServer.__pRoomVector.PushBack(disown pOwnedServerRoom);

											__pServer.__ClientJoin(this, pServerRoom);

											Console::Log("!!!!");
											

											//transition user to room
											break;
										}
									}
								}
							}
						}
						
						{
							Console::Log("Bad handshake, disconnecting");
							Blob* pResponseBlob = own new Blob(true);
							BlobView pResponseBlobView = pResponseBlob.GetBlobView();
							pResponseBlobView.PackUint8(gsError::Error::BAD_HANDSHAKE);
							__pClientSocket.Disconnect();
							return;
						}
					}
					else
					{
						// timeout kick
					}
					break;
				}
				case gsClient::State::CONNECTED:
				{
					break;
				}
				case gsClient::State::DISCONNECTED:
				{
					break;
				}
				default:
				{
					Assert::Plz(false);
				}
			}
		}
	}
	
}