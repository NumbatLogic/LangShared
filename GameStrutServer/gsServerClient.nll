namespace NumbatLogic
{
	class gsServerClient
	{
		public void Send(gsServerRoom pRoom, Uint32 nMessageTypeHash, gsBlob pBlob)
		{
			gsBlob* pSendBlob = own new gsBlob();
		
			Uint32 nSyncId = __nLastSyncId++;
			
			pSendBlob.PackBool(false);
			pSendBlob.PackUint32(nSyncId);
			pSendBlob.PackUint32(pRoom == null ? 0 : pRoom.__nRoomId);
			pSendBlob.PackUint32(nMessageTypeHash);
			pSendBlob.PackBlob(pBlob);
			
			__pClientSocket.Send(pSendBlob);
		}


		// The new client has completed authentication, now what?
		// Perhaps do any additional fetching, and send them to their room!
		public virtual void OnInitialJoin()
		{
		}


		// 

		public gsServerRoom GetRoomByRoomId(Uint32 nRoomId)
		{
			for (int i = 0; i < __pRoomVector.GetSize(); i++)
			{
				gsServerRoom pRoom = __pRoomVector.Get(i);
				if (pRoom.__nRoomId == nRoomId)
					return pRoom;
			}
			return null;
		}



		public void SyncRespond(Uint32 nSyncId, Uint8 nResult, bool bAwaitRoomChange, gsBlob pBlob)
		{
			gsBlob* pRespondBlob = own new gsBlob();
			
			pRespondBlob.PackBool(true);
			pRespondBlob.PackUint32(nSyncId);
			pRespondBlob.PackUint8(nResult);
			pRespondBlob.PackBool(bAwaitRoomChange);

			if (pBlob != null)
			{
				pRespondBlob.PackBool(true);
				pRespondBlob.PackBlob(pBlob);
			}
			else
			{
				pRespondBlob.PackBool(false);
			}

			__pClientSocket.Send(pRespondBlob);
		}


			



		// SEKRIT


		/*Uint8 nState;

		Uint16 nNettleVersion;
		Uint16 nVersion;

		Uint32 nClientId;
		//Uint32 nReconnectToken;

		nbVector* pRoomVector;

		Uint32 nLastSyncId;

		void* pPointer;*/
	
		public Uint32 __nClientId;
		public gsServer __pServer;
		public gsClientSocket __pClientSocket;
		public gsClient::State __eState;
		public Vector<gsServerRoom>* __pRoomVector;

		public Uint32 __nLastSyncId;

		public construct(Uint32 nClientId, gsClientSocket pClientSocket, gsServer pServer)
		{
			__nClientId = nClientId;
			__pServer = pServer;
			__pClientSocket = pClientSocket;
			__eState = gsClient::State::CONNECT;
			__pRoomVector = own new Vector<gsServerRoom>();
		}

		public void __Update()
		{
			__pClientSocket.Update();

			switch (__eState)
			{
				case gsClient::State::CONNECT:
				{
					__eState = gsClient::State::HANDSHAKE;
					break;
				}
				case gsClient::State::HANDSHAKE:
				{
					gsBlob* pReceiveBlob = own __pClientSocket.Receive();
					if (pReceiveBlob != null)
					{
						Uint16 nMagic;
						Uint16 nVersion;
						Uint8 nAuthMode;

						if (pReceiveBlob.UnpackUint16(ref nMagic) && pReceiveBlob.UnpackUint16(ref nVersion) && pReceiveBlob.UnpackUint8(ref nAuthMode))
						{
							if (nMagic == gsClient::MAGIC_WORD && nVersion == __pServer.__nVersion)
							{
								// success, move to room or auth or something
								if (nAuthMode == 0)
								{
									InternalString* sName = own new InternalString("");
									InternalString* sPassword = own new InternalString("");

									if (pReceiveBlob.UnpackInternalString(sName))
									{
										if (pReceiveBlob.UnpackInternalString(sPassword))
										{
											// TODO: validate

											gsBlob* pSendBlob = own new gsBlob();
											pSendBlob.PackUint16(gsClient::MAGIC_WORD);
											pSendBlob.PackUint16(__pServer.__nVersion);
											pSendBlob.PackBool(true);
											pSendBlob.PackUint32(__nClientId);
											__pClientSocket.Send(pSendBlob);

											__eState = gsClient::State::CONNECTED;

											OnInitialJoin();
											break;
										}
									}
								}
							}
						}
						
						{
							Console::Log("Bad handshake, disconnecting");
							gsBlob* pResponseBlob = own new gsBlob();
							pResponseBlob.PackUint8(cast Uint8(gsError::Error::BAD_HANDSHAKE)); // todo: need some actual protocol here...
							__pClientSocket.Disconnect();
							return;
						}
					}
					else
					{
						// timeout kick
					}
					break;
				}
				case gsClient::State::CONNECTED:
				{
					gsBlob* pReceiveBlob = own __pClientSocket.Receive();
					if (pReceiveBlob != null)
					{
						Uint32 nSyncId;
						Uint32 nLastSyncId;
						Uint32 nRoomId;
						Uint32 nSyncType;
						gsBlob* pSyncBlob = own new gsBlob();
						
						if (pReceiveBlob.UnpackUint32(ref nSyncId)
							&& pReceiveBlob.UnpackUint32(ref nLastSyncId)
							&& pReceiveBlob.UnpackUint32(ref nRoomId)
							&& pReceiveBlob.UnpackUint32(ref nSyncType)
							&& pReceiveBlob.UnpackBlob(pSyncBlob))
						{
							if (nRoomId > 0)
							{
								gsServerRoom pRoom = GetRoomByRoomId(nRoomId);

								if (pRoom == null)
								{
									ErrorDisconnect("Bad room");
									return;
								}
									
								pRoom.OnSync(nSyncId, nSyncType, pSyncBlob, this);
							}
							else
							{

							}
						}
						else
						{
							// todo: yeet client
							Assert::Plz(false);
						}
					}
					break;
				}
				case gsClient::State::DISCONNECTED:
				{
					break;
				}
				default:
				{
					Assert::Plz(false);
					break;
				}
			}
		}

		public void ErrorDisconnect(string sxErrorMessage)
		{
			Console::Log("Error disconnect");
			Console::Log(sxErrorMessage);

			// todo send disconnection sync
			
			//gsBlob* pBlob = own new gsBlob();
			//				pResponseBlob.PackUint8(gsError::Error::BAD_HANDSHAKE); // todo: need some actual protocol here...
			
			__pClientSocket.Disconnect();
		}
	}
	
}