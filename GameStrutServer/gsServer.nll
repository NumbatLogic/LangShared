namespace NumbatLogic
{
	class gsServer
	{
		public gsServerImplementation* m_pImpl;
		
        public construct(string sxAddress, Uint16 nPort, Uint16 nVersion, string sxDatabasePath)
		{
			m_pImpl = own new gsServerImplementation();

			m_pImpl.m_sAddress = own new InternalString(sxAddress);
			m_pImpl.m_nPort = nPort;
			m_pImpl.m_nVersion = nVersion;

			m_pImpl.m_pServerSocket = own new ServerSocket();
			m_pImpl.m_pServerSocket.Start(m_pImpl.m_nPort);

			m_pImpl.m_pServerRoomVector = own new OwnedVector<gsServerRoom>();
			m_pImpl.m_pServerClientVector = own new OwnedVector<gsServerClient>();
		}

		public destruct()
		{
			m_pImpl.m_pServerSocket.Stop();
		}

		public void Update()
		{
			m_pImpl.m_pServerSocket.Update();

			{
				ClientSocket pClientSocket = m_pImpl.m_pServerSocket.Accept();
				if (pClientSocket)
				{
					Console::Log("Accept!");

					gsServerClient* pServerClient = own CreateServerClient(pClientSocket);
					Assert::Plz(pServerClient != null);
					m_pImpl.m_pServerClientVector.PushBack(disown pServerClient);
				}
			}

			for (int i = 0; i < m_pImpl.m_pServerClientVector.GetSize(); i++)
			{
				gsServerClient pServerClient = m_pImpl.m_pServerClientVector.Get(i);

				pServerClient.m_pImpl.Update();

				
			}

			// cleanup
			{
				int i = 0;
				while (i < m_pImpl.m_pServerClientVector.GetSize())
				{
					gsServerClient pServerClient = m_pImpl.m_pServerClientVector.Get(i);
					if (!pServerClient.m_pImpl.m_pClientSocket.GetConnected())
					{
						/*while (nbVector_GetSize(pClient->pRoomVector) > 0)
							{
								nbNettle_ServerRoom* pRoom = nbVector_Get(pClient->pRoomVector, 0);
								nbNettle_ServerRoom_ClientLeave(pRoom, pClient);
							}
				
							if (pServer->pClientDestroy)
								pServer->pClientDestroy(pClient, pServer->pDatabase);
				
							nbClientSocket_Destroy(pClient->pClientSocket);
				
							nbAssert(nbVector_GetSize(pClient->pRoomVector) == 0);
							nbVector_Destroy(pClient->pRoomVector);
				
							nbFree(pClient);// todo: stop doing this in two places
				
							nbVector_Erase(pServer->pClientVector, i);*/
						
							m_pImpl.m_pServerClientVector.Erase(i);
						
						continue;
					}
					i++;
				}
			}
		}

		public bool Pending()
		{
			return m_pImpl.m_pServerSocket.Pending();
		}

		public virtual gsServerClient** CreateServerClient(ClientSocket pClientSocket)
		{
			return new gsServerClient(m_pImpl.m_nLastClientId++, this, pClientSocket);
		}

		public virtual void Auth(Blob pAuthBlob, ClientSocket pClientSocket)
		{
			Assert::Plz(false);
		}

		public void ClientJoin(gsServerClient pServerClient, gsServerRoom pServerRoom)
		{
			// TODO: load transition from DB
			// TODO: process id check
			
			// TODO: only kick from primary room
			while (pServerClient.m_pImpl.m_pServerRoomVector.GetSize())
			{
				gsServerRoom pCurrentServerRoom = pServerClient.m_pImpl.m_pServerRoomVector.Get(0);
				pCurrentServerRoom.m_pImpl.ClientLeave(pServerClient);
			}

			pServerRoom.m_pImpl.ClientJoin(pServerClient);
		}
	}

	class gsServerImplementation
	{
		public InternalString* m_sAddress;
		public Uint16 m_nPort;
		public Uint16 m_nVersion;

		public ServerSocket* m_pServerSocket;
		public OwnedVector<gsServerClient>* m_pServerClientVector;
		public OwnedVector<gsServerRoom>* m_pServerRoomVector;

		public Uint16 m_nLastClientId;
	}
}