namespace NumbatLogic
{
	class gsServer
	{
		public construct(string sxAddress, Uint16 nPort, Uint16 nVersion, string sxDatabasePath)
		{
			__sAddress = own new InternalString(sxAddress);
			__nPort = nPort;
			__nVersion = nVersion;

			__pServerSocket = own new gsServerSocket();
			__pServerSocket.Start(__nPort);

			__pRoomVector = own new OwnedVector<gsServerRoom>();
			__pClientVector = own new OwnedVector<gsServerClient>();
		}

		public destruct()
		{
			__pServerSocket.Stop();
		}

		public void Update()
		{
			__pServerSocket.Update();

			{
				gsClientSocket pClientSocket = __pServerSocket.Accept();
				if (pClientSocket)
				{
					gsServerClient* pServerClient = own OnCreateServerClient(__nLastClientId++, pClientSocket, this);
					Assert::Plz(pServerClient != null);
					__pClientVector.PushBack(disown pServerClient);
				}
			}

			for (int i = 0; i < __pClientVector.GetSize(); i++)
			{
				gsServerClient pServerClient = __pClientVector.Get(i);

				pServerClient.__Update();
			}

			// cleanup
			{
				int i = 0;
				while (i < __pClientVector.GetSize())
				{
					gsServerClient pServerClient = __pClientVector.Get(i);
					if (!pServerClient.__pClientSocket.GetConnected())
					{
						/*while (nbVector_GetSize(pClient->pRoomVector) > 0)
							{
								nbNettle_ServerRoom* pRoom = nbVector_Get(pClient->pRoomVector, 0);
								nbNettle_ServerRoom_ClientLeave(pRoom, pClient);
							}
				
							if (pServer->pClientDestroy)
								pServer->pClientDestroy(pClient, pServer->pDatabase);
				
							nbClientSocket_Destroy(pClient->pClientSocket);
				
							nbAssert(nbVector_GetSize(pClient->pRoomVector) == 0);
							nbVector_Destroy(pClient->pRoomVector);
				
							nbFree(pClient);// todo: stop doing this in two places
				
							nbVector_Erase(pServer->pClientVector, i);*/
						
							__pClientVector.Erase(i);
						
						continue;
					}
					i++;
				}
			}
		}

		public bool Pending()
		{
			return __pServerSocket.Pending();
		}

		public virtual gsServerClient** OnCreateServerClient(Uint32 nClientId, gsClientSocket pClientSocket, gsServer pServer)
		{
			return new gsServerClient(__nLastClientId++, pClientSocket, this);
		}

		public virtual gsServerRoom** OnCreateRoom(Uint32 nRoomId, Int32 nRoomType, Blob pCreateBlob)
		{
			return null;
		}


		public virtual void Auth(Blob pAuthBlob, gsClientSocket pClientSocket)
		{
			Assert::Plz(false);
		}


		// SEKRIT - Double underscores are internal implementation, no promises!
		// *******
		public InternalString* __sAddress;
		public Uint16 __nPort;
		public Uint16 __nVersion;

		public gsServerSocket* __pServerSocket;
		public OwnedVector<gsServerClient>* __pClientVector;
		public OwnedVector<gsServerRoom>* __pRoomVector;

		public Uint32 __nLastClientId;
		public Uint32 __nLastRoomId;


		public void __ClientJoin(gsServerClient pClient, gsServerRoom pRoom)
		{
			// TODO: load transition from DB
			// TODO: process id check
			
			// TODO: only kick from primary room
			while (pClient.__pRoomVector.GetSize())
			{
				gsServerRoom pCurrentRoom = pClient.__pRoomVector.Get(0);
				pCurrentRoom.__ClientLeave(pClient);
			}

			pRoom.__ClientJoin(pClient);
		}

		public gsServerRoom __CreateRoom(string sxRoomType, Blob pCreateBlob)
		{
			// hax probably not needed once we are DB based...
			BlobView pCreateBlobView = pCreateBlob.GetBlobView();
			pCreateBlobView.SetOffset(0);

			Int32 nRoomType = ExternalString::GetChecksum(sxRoomType);
			gsServerRoom* pOwnedRoom = own OnCreateRoom(++__nLastRoomId, nRoomType, pCreateBlob);
			Assert::Plz(pOwnedRoom != null);
			gsServerRoom pRoom = pOwnedRoom;
			__pRoomVector.PushBack(disown pOwnedRoom);
			return pRoom;
		}
	}
}