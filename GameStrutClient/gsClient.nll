namespace NumbatLogic
{
	class gsClient
	{
		public enum State {
			CONNECT,
			HANDSHAKE,
			CONNECTED,
			DISCONNECTED
		}

		public construct(string sxAddress, Uint16 nPort, Uint16 nVersion)
		{
			__pRoomVector = own new OwnedVector<gsClientRoom>();

			__pClientSocket = own new ClientSocket();
			__pClientSocket.Connect(sxAddress, nPort);
			__nVersion = nVersion;
			__eState = CONNECT;

			__ROOM_JOIN_HASH = ExternalString::GetChecksum("__RoomJoin");
		}

		public destruct()
		{
			__pClientSocket.Disconnect();
		}

		public void Update()
		{
			__pClientSocket.Update();

			switch (__eState)
			{
				case State::CONNECT:
				{
					if (!__pClientSocket.Pending())
					{
						__eState = State::HANDSHAKE;
						
						Blob* pSendBlob = own new Blob(true);
						BlobView pBlobView = pSendBlob.GetBlobView();
						pBlobView.PackUint16(MAGIC_WORD);
						pBlobView.PackUint16(__nVersion);

						pBlobView.PackUint8(0); // auth mode

						InternalString* sName = own new InternalString("cliffya");
						pBlobView.PackInternalString(sName);

						InternalString* sPassword = own new InternalString("password");
						pBlobView.PackInternalString(sPassword);

						__pClientSocket.Send(pSendBlob);

						Console::Log("client send!");
					}
					break;
				}
				case State::HANDSHAKE:
				{
					Blob* pReceiveBlob = own __pClientSocket.Receive();
					if (pReceiveBlob != null)
					{
						const int INITIAL_SIZE = 2 + 2 + 1 + 4;
						if (pReceiveBlob.GetSize() == INITIAL_SIZE)
						{
							BlobView pRecieveBlobView = pReceiveBlob.GetBlobView();

							Uint16 nMagic = pRecieveBlobView.UnpackUint16();
							Uint16 nVersion = pRecieveBlobView.UnpackUint16();
							bool bSuccess = pRecieveBlobView.UnpackBool();
							
							if (nMagic == gsClient::MAGIC_WORD && bSuccess)
							{
								__nClientId = pRecieveBlobView.UnpackUint32();
								__eState = State::CONNECTED;
								break;
							}
						}
						
						// todo: nice shutdown + error
						Console::Log("bad handshake?");
						Assert::Plz(false);
					}
					break;
				}
				case State::CONNECTED:
				{
					Blob* pReceiveBlob = own __pClientSocket.Receive();
					if (pReceiveBlob != null)
					{
						BlobView pReceiveBlobView = pReceiveBlob.GetBlobView();

						Uint32 nSyncId = pReceiveBlobView.UnpackUint32();
						Uint32 nRoomId = pReceiveBlobView.UnpackUint32();
						Int32 nMessageType = pReceiveBlobView.UnpackInt32();
						Blob* pMessageBlob = own new Blob(true);
						if (!pReceiveBlobView.UnpackBlob(pMessageBlob))
							Assert::Plz(false);
						BlobView pMessageBlobView = pMessageBlob.GetBlobView();
						
						if (nRoomId == 0)
						{
							if (nMessageType == __ROOM_JOIN_HASH)
							{
								Uint32 nRoomId = pMessageBlobView.UnpackUint32();
								Int32 nRoomType = pMessageBlobView.UnpackInt32();
								bool bPrimary = pMessageBlobView.UnpackBool();
								Blob* pJoinBlob = own new Blob(true);
								if (!pMessageBlobView.UnpackBlob(pJoinBlob))
									Assert::Plz(false);
								

								gsClientRoom* pRoom = own OnRoomJoin(nRoomId, nRoomType, bPrimary, pJoinBlob);
								Assert::Plz(pRoom != null);
								__pRoomVector.PushBack(disown pRoom);
							}
							else
							{
								Console::Log("unknown hash");
								Assert::Plz(false);
							}
						}
					}

					break;
				}
				case State::DISCONNECTED:
				{
					break;
				}
				default:
				{
					Assert::Plz(false);
				}
			}
		}

		public bool Pending()
		{
			return __pClientSocket.Pending();
		}

		public virtual gsClientRoom** OnRoomJoin(Uint32 nRoomId, Int32 nRoomType, bool bPrimary, Blob pJoinBlob)
		{
			return new gsClientRoom(nRoomId, null, nRoomType, bPrimary);
		}
	
		
		// SEKRIT

		public static const Uint16 MAGIC_WORD = 619;

		public OwnedVector<gsClientRoom>* __pRoomVector;

		public ClientSocket* __pClientSocket;
		public Uint16 __nVersion;

		public Uint32 __nClientId;

		

		public State __eState;

		public Uint32 __ROOM_JOIN_HASH;
	}
}