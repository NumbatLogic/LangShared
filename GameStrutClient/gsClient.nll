namespace NumbatLogic
{
	class gsClient
	{
		public enum State {
			CONNECT,
			HANDSHAKE,
			CONNECTED,
			DISCONNECTED
		}

		public construct(string sxAddress, Uint16 nPort, Uint16 nVersion)
		{
			__pRoomVector = own new OwnedVector<gsClientRoom>();

			__pClientSocket = own new gsClientSocket();
			__pClientSocket.Connect(sxAddress, nPort);
			__nVersion = nVersion;
			__eState = State::CONNECT;

			__pSyncInnerVector = own new OwnedVector<gsSyncInner>();

			// should dis be static?
			__ROOM_JOIN_HASH = ExternalString::GetChecksum("__RoomJoin");
		}

		public destruct()
		{
			__pClientSocket.Disconnect();
		}

		public void Update()
		{
			__pClientSocket.Update();

			switch (__eState)
			{
				case State::CONNECT:
				{
					if (!__pClientSocket.Pending())
					{
						__eState = State::HANDSHAKE;
						
						gsBlob* pSendBlob = own new gsBlob();
						pSendBlob.PackUint16(MAGIC_WORD);
						pSendBlob.PackUint16(__nVersion);

						pSendBlob.PackUint8(0); // auth mode

						InternalString* sName = own new InternalString("cliffya");
						pSendBlob.PackInternalString(sName);

						InternalString* sPassword = own new InternalString("password");
						pSendBlob.PackInternalString(sPassword);

						__pClientSocket.Send(pSendBlob);
					}
					break;
				}
				case State::HANDSHAKE:
				{
					gsBlob* pReceiveBlob = own __pClientSocket.Receive();
					if (pReceiveBlob != null)
					{
						// can remove size check
						const int INITIAL_SIZE = 2 + 2 + 1 + 4;
						if (pReceiveBlob.GetSize() == INITIAL_SIZE)
						{
							Uint16 nMagic;
							Uint16 nVersion;
							bool bSuccess;

							if (pReceiveBlob.UnpackUint16(ref nMagic) && pReceiveBlob.UnpackUint16(ref nVersion) && pReceiveBlob.UnpackBool(ref bSuccess))
							{
								if (nMagic == gsClient::MAGIC_WORD && bSuccess)
								{
									if (!pReceiveBlob.UnpackUint32(ref __nClientId))
										Assert::Plz(false);
									__eState = State::CONNECTED;
									break;
								}
							}
						}
						
						// todo: nice shutdown + error
						Console::Log("bad handshake?");
						Assert::Plz(false);
					}
					break;
				}
				case State::CONNECTED:
				{
					gsBlob* pReceiveBlob = own __pClientSocket.Receive();
					if (pReceiveBlob != null)
					{
						bool bSyncResponse;
						Uint32 nSyncId;

						if (!pReceiveBlob.UnpackBool(ref bSyncResponse) || !pReceiveBlob.UnpackUint32(ref nSyncId))
						{
							Console::Log("bad blob?");
							Assert::Plz(false);
						}

						if (bSyncResponse)
						{
							gsSyncInner pSyncInner = GetSyncInnerBySyncId(nSyncId);
							Assert::Plz(pSyncInner != null);

							gsBlob* pSyncBlob = own new gsBlob();
							if (!pReceiveBlob.UnpackBlob(pSyncBlob))
								Assert::Plz(false);

							pSyncInner.OnComplete(pSyncBlob);
						}
						else
						{
							Uint32 nRoomId;
							Uint32 nMessageType;

							if (!pReceiveBlob.UnpackUint32(ref nRoomId) || !pReceiveBlob.UnpackUint32(ref nMessageType))
								Assert::Plz(false);

							gsBlob* pMessageBlob = own new gsBlob();
							if (!pReceiveBlob.UnpackBlob(pMessageBlob))
								Assert::Plz(false);
							
							if (nRoomId == 0)
							{
								if (nMessageType == __ROOM_JOIN_HASH)
								{
									//Uint32 nRoomId;
									Uint32 nRoomType;
									bool bPrimary;

									if (!pMessageBlob.UnpackUint32(ref nRoomId) || !pMessageBlob.UnpackUint32(ref nRoomType) || !pMessageBlob.UnpackBool(ref bPrimary))
										Assert::Plz(false);

									gsBlob* pJoinBlob = own new gsBlob();
									if (!pMessageBlob.UnpackBlob(pJoinBlob))
										Assert::Plz(false);
									

									gsClientRoom* pRoom = own OnRoomJoin(nRoomId, nRoomType, bPrimary, pJoinBlob);
									Assert::Plz(pRoom != null);
									__pRoomVector.PushBack(disown pRoom);
								}
								else
								{
									Console::Log("unknown hash");
									Assert::Plz(false);
								}
							}
						}
					}

					// check and delete complete syncs
					int i = 0;
					while (i < __pSyncInnerVector.GetSize())
					{
						gsSyncInner pSyncInner = __pSyncInnerVector.Get(i);
						if (pSyncInner.__bComplete && pSyncInner.__pSync == null)
						{
							__pSyncInnerVector.Erase(i);
							continue;
						}
						i++;
					}
								

					break;
				}
				case State::DISCONNECTED:
				{
					break;
				}
				default:
				{
					Assert::Plz(false);
					break;
				}
			}
		}

		public delegate void CompleteCallback();
		public void SyncSend(gsSync pSync, string sxSyncType, gsBlob pBlob, bool mayChangeRoom, gsClientRoom pRoom)
		{
			gsSyncInner* pSyncInner = own new gsSyncInner(pSync, ++__nLastSyncId, sxSyncType, pRoom, this);
			
			gsBlob* pSendBlob = own new gsBlob();
			pSendBlob.PackUint32(pSyncInner.__nSyncId);
			pSendBlob.PackUint32(0); // last accepted
			if (pRoom != null)
				pSendBlob.PackUint32(pRoom.__nRoomId);
			else
				pSendBlob.PackUint32(0);
			pSendBlob.PackUint32(pSyncInner.__nSyncType);
			pSendBlob.PackBlob(pBlob);

			__pClientSocket.Send(pSendBlob);


			pSyncInner.__pSync.__pSyncInner = pSyncInner;

			__pSyncInnerVector.PushBack(disown pSyncInner);
		}

		public bool GetPending()
		{
			return __pClientSocket.Pending();
		}

		public virtual gsClientRoom** OnRoomJoin(Uint32 nRoomId, Uint32 nRoomTypeHash, bool bPrimary, gsBlob pJoinBlob)
		{
			return new gsClientRoom(nRoomId, null, nRoomTypeHash, bPrimary, this);
		}
	
		
		// SEKRIT

		public static const Uint16 MAGIC_WORD = 619;

		public OwnedVector<gsClientRoom>* __pRoomVector;


		public gsClientSocket* __pClientSocket;
		public Uint16 __nVersion;

		public Uint32 __nClientId;

		public Uint32 __nLastSyncId;
		public OwnedVector<gsSyncInner>* __pSyncInnerVector;
		

		public State __eState;

		public Uint32 __ROOM_JOIN_HASH;



		public gsSyncInner GetSyncInnerBySyncId(Uint32 nSyncId)
		{
			for (int i = 0; i < __pSyncInnerVector.GetSize(); i++)
			{
				gsSyncInner pSyncInner = __pSyncInnerVector.Get(i);
				if (nSyncId == pSyncInner.__nSyncId)
					return pSyncInner;
			}
			return null;
		}
	}
}