namespace NumbatLogic
{
	class gsClient_SyncHandler
	{
		public delegate void SyncHandler(gsClient pClient, Uint32 nSyncId, gsBlob pMessageBlob);

		public Uint32 __nHash;
		public SyncHandler __pHandler;

		public construct(Uint32 nHash, SyncHandler pHandler)
		{
			__nHash = nHash;
			__pHandler = pHandler;
		}
	}

	class gsClient
	{
		public enum State {
			CONNECT,
			HANDSHAKE,
			CONNECTED,
			DISCONNECTED,
			ERRORED
		}

		public construct(string sxAddress, Uint16 nPort, Uint16 nVersion)
		{
			__pRoomVector = own new OwnedVector<gsClientRoom>();

			__pClientSocket = own new gsClientSocket();
			__pClientSocket.Connect(sxAddress, nPort);
			__nVersion = nVersion;
			__eState = State::CONNECT;
			__pSyncInnerVector = own new OwnedVector<gsSyncInner>();
			__pSyncHandlerVector = own new OwnedVector<gsClient_SyncHandler>();

			RegisterHandler(__ROOM_JOIN_HASH, __OnRoomJoin);
			RegisterHandler(__ROOM_LEAVE_HASH, __OnRoomLeave);
		}

		public destruct()
		{
			__pClientSocket.Disconnect();
		}

		public void Update()
		{
			__pClientSocket.Update();

			switch (__eState)
			{
				case State::CONNECT:
				{
					if (!__pClientSocket.Pending())
					{
						__eState = State::HANDSHAKE;
						
						gsBlob* pSendBlob = own new gsBlob();
						pSendBlob.PackUint16(MAGIC_WORD);
						pSendBlob.PackUint16(__nVersion);

						pSendBlob.PackUint8(0); // auth mode

						InternalString* sName = own new InternalString("cliffya");
						pSendBlob.PackInternalString(sName);

						InternalString* sPassword = own new InternalString("password");
						pSendBlob.PackInternalString(sPassword);

						__pClientSocket.Send(pSendBlob);
					}
					break;
				}
				case State::HANDSHAKE:
				{
					gsBlob* pReceiveBlob = own __pClientSocket.Receive();
					if (pReceiveBlob != null)
					{
						// can remove size check
						const int INITIAL_SIZE = 2 + 2 + 1 + 4;
						if (pReceiveBlob.GetSize() == INITIAL_SIZE)
						{
							Uint16 nMagic;
							Uint16 nVersion;
							bool bSuccess;

							if (pReceiveBlob.UnpackUint16(ref nMagic) && pReceiveBlob.UnpackUint16(ref nVersion) && pReceiveBlob.UnpackBool(ref bSuccess))
							{
								if (nMagic == gsClient::MAGIC_WORD && bSuccess)
								{
									if (!pReceiveBlob.UnpackUint32(ref __nClientId))
										Assert::Plz(false);
									__eState = State::CONNECTED;
									break;
								}
							}
						}
						
						// todo: nice shutdown + error
						Console::Log("bad handshake?");
						Assert::Plz(false);
					}
					break;
				}
				case State::CONNECTED:
				{
					gsBlob* pReceiveBlob = own __pClientSocket.Receive();
					if (pReceiveBlob != null)
					{
						bool bSyncResponse;
						Uint32 nSyncId;

						if (!pReceiveBlob.UnpackBool(ref bSyncResponse) || !pReceiveBlob.UnpackUint32(ref nSyncId))
						{
							Console::Log("bad blob?");
							Assert::Plz(false);
						}

						if (bSyncResponse)
						{
							gsSyncInner pSyncInner = GetSyncInnerBySyncId(nSyncId);
							Assert::Plz(pSyncInner != null);

							Uint8 nResult;
							if (!pReceiveBlob.UnpackUint8(ref nResult))
								Assert::Plz(false);

							Uint8 nResponseRaw;
							if (!pReceiveBlob.UnpackUint8(ref nResponseRaw))
								Assert::Plz(false);
							gsSync::Response eResponse = cast gsSync::Response(nResponseRaw);

							if (nResult == gsSync::RESULT_SUCCESS && eResponse != pSyncInner.__eResponse)
							{
								ErrorDisconnect("Response expectation mismatch");
								return;
							}

							bool bHasBlob;
							if (!pReceiveBlob.UnpackBool(ref bHasBlob))
								Assert::Plz(false);

							gsBlob* pSyncBlob = null;
							if (bHasBlob)
							{
								pSyncBlob = own new gsBlob();
								if (!pReceiveBlob.UnpackBlob(pSyncBlob))
									Assert::Plz(false);
							}

							if (eResponse != gsSync::Response::EXPECT_ROOM_CHANGE)
								pSyncInner.__bComplete = true;

							// Don't call on complete on error??
							pSyncInner.__nResult = nResult;
							if (pSyncInner.__pSync != null)
								pSyncInner.__pSync.OnComplete(nResult, pSyncBlob);
						}
						else
						{
							Uint32 nRoomId;
							Uint32 nMessageType;

							if (!pReceiveBlob.UnpackUint32(ref nRoomId) || !pReceiveBlob.UnpackUint32(ref nMessageType))
								Assert::Plz(false);

							gsBlob* pMessageBlob = own new gsBlob();
							if (!pReceiveBlob.UnpackBlob(pMessageBlob))
								Assert::Plz(false);
							
							if (nRoomId == 0)
							{
								gsClient_SyncHandler pHandler = __GetSyncHandler(nMessageType);
								if (pHandler == null)
								{
									ErrorDisconnect("No handler registered for sync message");
									return;
								}
								pHandler.__pHandler(this, nSyncId, pMessageBlob);
							}
							else
							{
								gsClientRoom pRoom = GetRoomByRoomId(nRoomId);
								if (pRoom == null)
								{
									ErrorDisconnect("Bad room id");
									return;
								}
								gsClientRoom_SyncHandler pHandler = pRoom.__GetSyncHandler(nMessageType);
								if (pHandler == null)
								{
									ErrorDisconnect("No handler registered for room sync message");
									return;
								}
								pHandler.__pHandler(this, pRoom, nSyncId, pMessageBlob);
							}
						}
					}

					int i = 0;
					while (i < __pSyncInnerVector.GetSize())
					{
						gsSyncInner pSyncInner = __pSyncInnerVector.Get(i);
						if (pSyncInner.__eResponse == gsSync::Response::EXPECT_ROOM_CHANGE && !pSyncInner.__bComplete)
						{
							int j;
							for (j = 0; j < __pRoomVector.GetSize(); j++)
							{
								gsClientRoom pRoom = __pRoomVector.Get(j);
								if (pRoom.__nRoomId == pSyncInner.__nRoomId)
									break;
							}

							if (j == __pRoomVector.GetSize())
							{
								pSyncInner.__eResponse = gsSync::Response::NO_RESPONSE;
								pSyncInner.__bComplete = true;
							}
						}

						if (pSyncInner.__bComplete && pSyncInner.__pSync == null)
						{
							__pSyncInnerVector.Erase(i);
							continue;
						}
						i++;
					}
								

					break;
				}
				case State::DISCONNECTED:
				{
					break;
				}
				case State::ERRORED:
				{
					break;
				}
				default:
				{
					Assert::Plz(false);
					break;
				}
			}
		}

		public static void __OnRoomJoin(gsClient pClient, Uint32 nSyncId, gsBlob pMessageBlob)
		{
			Uint32 nRoomId;
			Uint32 nRoomType;
			bool bPrimary;
			if (pMessageBlob.UnpackUint32(ref nRoomId) && pMessageBlob.UnpackUint32(ref nRoomType) && pMessageBlob.UnpackBool(ref bPrimary))
			{
				gsBlob* pJoinBlob = own new gsBlob();
				if (pMessageBlob.UnpackBlob(pJoinBlob))
				{
					gsClientRoom* pRoom = own pClient.OnRoomJoin(nRoomId, nRoomType, bPrimary, pJoinBlob);
					if (pRoom != null)
					{
						pClient.__pRoomVector.PushBack(disown pRoom);
						return;
					}
				}
			}
			pClient.ErrorDisconnect("Room join failed");
		}

		public static void __OnRoomLeave(gsClient pClient, Uint32 nSyncId, gsBlob pMessageBlob)
		{
			Uint32 nLeaveRoomId;
			Uint32 nLeaveRoomType;
			if (pMessageBlob.UnpackUint32(ref nLeaveRoomId) && pMessageBlob.UnpackUint32(ref nLeaveRoomType))
			{
				for (int i = 0; i < pClient.__pRoomVector.GetSize(); i++)
				{
					if (pClient.__pRoomVector.Get(i).__nRoomId == nLeaveRoomId)
					{
						pClient.__pRoomVector.Erase(i);
						return;
					}
				}
			}
			pClient.ErrorDisconnect("Room leave failed");
		}

		public void RegisterHandler(Uint32 nMessageType, gsClient_SyncHandler::SyncHandler pHandler)
		{
			if (__GetSyncHandler(nMessageType) != null)
			{
				Console::Log("Sync handler hash already registered!");
				Assert::Plz(false);
			}
			__pSyncHandlerVector.PushBack(new gsClient_SyncHandler(nMessageType, pHandler));
		}

		public gsClient_SyncHandler __GetSyncHandler(Uint32 nMessageType)
		{
			for (int i = 0; i < __pSyncHandlerVector.GetSize(); i++)
			{
				gsClient_SyncHandler pInfo = __pSyncHandlerVector.Get(i);
				if (pInfo.__nHash == nMessageType)
					return pInfo;
			}
			return null;
		}

		public void SyncSend(gsSync pSync, string sxSyncType, gsBlob pBlob, gsSync::Response eResponse, gsClientRoom pRoom)
		{
			gsSyncInner* pSyncInner = own new gsSyncInner(pSync, ++__nLastSyncId, sxSyncType, pRoom, this);
			pSyncInner.__eResponse = eResponse;
			
			gsBlob* pSendBlob = own new gsBlob();
			pSendBlob.PackUint32(pSyncInner.__nSyncId);
			pSendBlob.PackUint32(0); // last accepted
			if (pRoom != null)
				pSendBlob.PackUint32(pRoom.__nRoomId);
			else
				pSendBlob.PackUint32(0);
			pSendBlob.PackUint32(pSyncInner.__nSyncType);
			pSendBlob.PackBlob(pBlob);

			__pClientSocket.Send(pSendBlob);

			pSyncInner.__pSync.__pSyncInner = pSyncInner;

			if (pSyncInner.__eResponse == gsSync::Response::NO_RESPONSE)
				pSyncInner.__bComplete = true;

			__pSyncInnerVector.PushBack(disown pSyncInner);
		}

		public bool GetPending()
		{
			if (__eState == State::ERRORED)
				return false;

			if (__pClientSocket.Pending())
				return true;

			if (!__pClientSocket.GetConnected())
				return false;

			for (int i = 0; i < __pSyncInnerVector.GetSize(); i++)
			{
				gsSyncInner pSyncInner = __pSyncInnerVector.Get(i);
				if (!pSyncInner.__bComplete)
					return true;
			}

			return false;
		}

		public bool HasActiveSync()
		{
			for (int i = 0; i < __pSyncInnerVector.GetSize(); i++)
			{
				gsSyncInner pSyncInner = __pSyncInnerVector.Get(i);
				if (!pSyncInner.__bComplete)
					return true;
			}
			return false;
		}

		public bool HasActiveSyncByRoom(gsClientRoom pRoom)
		{
			for (int i = 0; i < __pSyncInnerVector.GetSize(); i++)
			{
				gsSyncInner pSyncInner = __pSyncInnerVector.Get(i);
				if (pSyncInner.__nRoomId == pRoom.__nRoomId && !pSyncInner.__bComplete)
					return true;
			}
			return false;
		}

		public virtual gsClientRoom** OnRoomJoin(Uint32 nRoomId, Uint32 nRoomTypeHash, bool bPrimary, gsBlob pJoinBlob)
		{
			return new gsClientRoom(nRoomId, null, nRoomTypeHash, bPrimary, this);
		}
	
		
		// SEKRIT

		public static const Uint16 MAGIC_WORD = 619;

		public OwnedVector<gsClientRoom>* __pRoomVector;


		public gsClientSocket* __pClientSocket;
		public Uint16 __nVersion;

		public Uint32 __nClientId;

		public Uint32 __nLastSyncId;
		public OwnedVector<gsSyncInner>* __pSyncInnerVector;
		public OwnedVector<gsClient_SyncHandler>* __pSyncHandlerVector;
		

		public State __eState;
		public InternalString* __sErrorMessage;

		public static Uint32 __ROOM_JOIN_HASH = tthash("__RoomJoin");
		public static Uint32 __ROOM_LEAVE_HASH = tthash("__RoomLeave");



		public gsClientRoom GetRoomByRoomId(Uint32 nRoomId)
		{
			for (int i = 0; i < __pRoomVector.GetSize(); i++)
			{
				gsClientRoom pRoom = __pRoomVector.Get(i);
				if (pRoom.__nRoomId == nRoomId)
					return pRoom;
			}
			return null;
		}

		public void ErrorDisconnect(string sxErrorMessage)
		{
			Console::Log("Error disconnect");
			Console::Log(sxErrorMessage);
			__sErrorMessage = own new InternalString(sxErrorMessage);
			__eState = State::ERRORED;
			__pClientSocket.Disconnect();
		}

		public string GetErrorMessage()
		{
			Assert::Plz(__eState == State::ERRORED);
			return __sErrorMessage.GetExternalString();
		}

		public gsSyncInner GetSyncInnerBySyncId(Uint32 nSyncId)
		{
			for (int i = 0; i < __pSyncInnerVector.GetSize(); i++)
			{
				gsSyncInner pSyncInner = __pSyncInnerVector.Get(i);
				if (nSyncId == pSyncInner.__nSyncId)
					return pSyncInner;
			}
			return null;
		}
	}
}