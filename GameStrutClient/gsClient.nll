namespace NumbatLogic
{
	class gsClient
	{
		public enum State {
			CONNECT,
			HANDSHAKE,
			CONNECTED,
			DISCONNECTED
		}

		public construct(string sxAddress, Uint16 nPort, Uint16 nVersion)
		{
			__pClientSocket = own new ClientSocket();
			__pClientSocket.Connect(sxAddress, nPort);
			__nVersion = nVersion;
			__eState = CONNECT;
		}

		public destruct()
		{
			__pClientSocket.Disconnect();
		}

		public void Update()
		{
			__pClientSocket.Update();

			switch (__eState)
			{
				case State::CONNECT:
				{
					if (!__pClientSocket.Pending())
					{
						__eState = State::HANDSHAKE;
						
						Blob* pSendBlob = own new Blob(true);
						BlobView pBlobView = pSendBlob.GetBlobView();
						pBlobView.PackUint16(MAGIC_WORD);
						pBlobView.PackUint16(__nVersion);

						pBlobView.PackUint8(0); // auth mode

						InternalString* sName = own new InternalString("cliffya");
						pBlobView.PackInternalString(sName);

						InternalString* sPassword = own new InternalString("password");
						pBlobView.PackInternalString(sPassword);

						__pClientSocket.Send(pSendBlob);

						Console::Log("client send!");
					}
					break;
				}
				case State::HANDSHAKE:
				{
					Blob* pReceiveBlob = own __pClientSocket.Receive();
					if (pReceiveBlob != null)
					{
						Console::Log("client recieve!");

						const int INITIAL_SIZE = 2 + 2 + 1 + 4;
						if (pReceiveBlob.GetSize() == INITIAL_SIZE)
						{
							BlobView pRecieveBlobView = pReceiveBlob.GetBlobView();

							Uint16 nMagic = pRecieveBlobView.UnpackUint16();
							Uint16 nVersion = pRecieveBlobView.UnpackUint16();
							bool bSuccess = pRecieveBlobView.UnpackBool();
							
							if (nMagic == gsClient::MAGIC_WORD && bSuccess)
							{
								__nClientId = pRecieveBlobView.UnpackUint32();

								Console::Log("good handshake!!!!!");
								__eState = State::CONNECTED;
								break;
							}
						}
						
						// todo: nice shutdown + error
						Console::Log("bad handshake?");
						Assert::Plz(false);
					}
					break;
				}
				case State::CONNECTED:
				{
					break;
				}
				case State::DISCONNECTED:
				{
					break;
				}
				default:
				{
					Assert::Plz(false);
				}
			}
		}

		public bool Pending()
		{
			return __pClientSocket.Pending();
		}
	
		
		// SEKRIT

		public static const Uint16 MAGIC_WORD = 619;

		public ClientSocket* __pClientSocket;
		public Uint16 __nVersion;

		public Uint32 __nClientId;

		public State __eState;
	}
}